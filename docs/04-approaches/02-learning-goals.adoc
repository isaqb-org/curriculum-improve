// tag::DE[]
=== {learning-goals}
[[LZ-4-01]]
==== LZ 4-01: Optimieren von Entwicklungsprozessen durch geeignete Maßnahmen

Siehe auch <<LZ-2-10>>.

Hierzu zählen beispielsweise:

* Dezentralisierung bzw. Zentralisierung von Entwicklungsprozessen.
* Einsatz iterativer Prozesse zur Reduktion von Risiken.
* Verringerung von Wartezeiten und Puffern zur Beschleunigung von Entwicklungsprozessen.
* Identifikation kritischer Bestandteile (Personen, Organisationseinheiten) in Entwicklungsprozessen und deren Entlastung.


[[LZ-4-02]]
==== LZ 4-02: Verbessern von  Quellcode

Siehe auch <<LZ-2-06>>.

Softwarearchitekt:innen sollten:

* Für Technologien/Programmiersprachen typische Refactorings (verhaltenserhaltende Vereinfachungsmaßnahmen im Quellcode) kennen und anwenden können.
* Technologien besser nutzen und bessere Technologie einführen können(Technologiewechsel).
* Maßnahmen und Muster zur Reduktion von Kopplung in Quellcode kennen und beurteilen können.
* Maßnahmen und Muster zur Verbesserung der Verständlichkeit von Quellcode kennen, beispielsweise _Clean-Code_ Prinzipien.

[[LZ-4-03]]
==== LZ 4-03: Reduzieren von Änderungsrisiken durch Automatisierung

Softwarearchitekt:innen sollten beispielsweise:

* automatisierte Tests (Unit-, Integrations-, Akzeptanz-, Regressionstests) als Mittel zur Früherkennung von Fehlern nach Änderungen konzipieren und umsetzen können,
* erkennen können, an welchen Stellen (etwa: Schnittstellen oder Komponenten) automatisierte Tests angemessen oder notwendig sind,
* weitere Methoden der Automatisierung kennen, die systematisch Änderungsrisiken und -aufwände reduzieren können, beispielsweise: 
** Continuous Integration
** Continuous Delivery
** Model-driven Development/Generative Development
** Infrastructure-As-Code
** Docs-As-Code
** Diagrams-As-Code


[[LZ-4-04]]
==== LZ 4-04: Reduzieren von Kopplung innerhalb von Systemen

Softwarearchitekt:innen:

* kennen typische Muster oder Lösungsansätze zur Reduktion von Kopplung und können diese anwenden (beispielsweise Modularisierung/Komponentenbildung, Entkopplung über Interfaces, Dependency-Injection, Kapselung, Adapter, Wrapper, Gateway), zeitliche Entkopplung über Asynchronität)
* können deren Effekte (Wirkungen und Nebenwirkungen), ggfs. unter Zuhilfenahme entsprechender Werkzeuge, nachvollziehen.

[[LZ-4-05]]
==== LZ 4-05: Lösen von daten- und datenbank-bezogenen Problemen

Siehe <<LZ-2-09>>.

Beispiele für solche Ansätze sind:

* _Deprecation Period_ für Datenbank-Refactoring (siehe <<amblersadalage>>).
* Aufteilen oder Zusammenführen von Datenbanken zur Verbesserung der erforderlichen Eigenschaften.
* Anpassen von Datenstrukturen/-typen an aktuelle Anforderungen, einschließlich Entwerfen und Implementieren von Datenmigrationen.
* Technische Optionen wie Indizierung, Caching, Abfrageoptimierung, Partitionierung, Sharding
* Techniken zur Erreichung oder Aufrechterhaltung der Konsistenz über replizierte oder verteilte Daten hinweg.

Softwarearchitekt:innen kennen die Herausforderungen von:

* gemeinsam genutzten, verteilten oder replizierten Daten, wie Schreibkonflikte, Integritätsverletzungen, Inkonsistenzen.
* Versionierung von Datenstrukturen und Daten.


[[LZ-4-06]]
==== LZ 4-06: Verbessern des Laufzeitverhaltens von Systemen

Technologiespezifische Muster und Praktiken zur Verbesserung von Laufzeiteigenschaften kennen und anwenden können (die detaillierte Auswahl obliegt dem Schulungs-/Trainingsanbieter).

[[LZ-4-07]]
==== LZ 4-07: Verbessern der Betreibbarkeit von Systemen

(Unter Umständen technologiespezifische) Muster und Praktiken zur Verbesserung der Betreibbarkeit kennen (die detaillierte Auswahl obliegt dem Schulungs-/Trainingsanbieter).

[[LZ-4-08]]
==== LZ 4-08: Verbessern der technischen Dokumentation

Softwarearchitekt:innen kennen Grundlegende Möglichkeiten zur systematischen Verbesserung von technischer Dokumentation und können diese anwenden, beispielsweise:

* Einhaltung etablierter Dokumentationsstrukturen (z. B. Templates)
* Gezielte Reduktion von Dokumentationsumfang durch Abstraktion oder inhaltliche Fokussierung
* Top-Down-Kommunikation
* Trennung struktureller (spezifischer) und konzeptioneller (übergreifender) Inhalte
* Modularisierung von Dokumentation

// end::DE[]

// tag::EN[]
=== {learning-goals}

[[LG-4-01]]
==== LG 4-01: Optimize development processes using suitable measures

See also <<LG-2-10>>.

These include, for example:

* Decentralization vs. centralization of development processes.
* Employment of iterative processes to reduce risks.
* Reduce idle times and buffers to accelerate development processes.
* Identify critical parts (people, organizational units) in development processes and possible ways to relieve them.

[[LG-4-02]]
==== LG 4-02: Improve source code

See also <<LG-2-06>>.

Software architects should:

* know and assess typical technology/programming language-specific refactorings (semantics preserving simplification measures in source code).
* know how to improve use of technology or how to introduce better technology (change of technology).
* know and be able to assess measures and patterns to reduce coupling at source code level.
* know measures and patterns to make source code more comprehensible, e.g., _Clean Code_ principles.


[[LG-4-03]]
==== LG 4-03: Reduce change risks through automation

Software architects should, for example:

* be able to design and implement automated tests (unit, integration, acceptance, regression tests) as a means of early detection of errors after changes,
* be able to recognize where (e.g., interfaces or components) automated tests are appropriate or necessary,
* be familiar with other automation methods that can systematically reduce change risks and effort, for example: 
** Continuous integration
** Continuous delivery
** Model-driven development/generative development
** Infrastructure-as-code
** Docs-as-code
** Diagrams-as-code


[[LG-4-04]]
==== LG 4-04: Reduce coupling within systems

Software architects:
* know typical patterns or approaches to reduce internal coupling and can apply these (e.g., modularization/component building, decoupling via interfaces, dependency injection, encapsulation, adapter, wrapper, gateway, decoupling of control flow with asynchronous invocation).
* understand their impact (effects and side-effects), possibly by using appropriate tools.


[[LG-4-05]]
==== LG 4-05: Solve data- and database-related problems

See <<LG-2-09>>.

Examples of such approaches include:

* _Deprecation period_ pattern for database refactoring (see <<amblersadalage>>).
* Splitting or merging databases to improve required qualities.
* Adjusting data structures/types to current requirements, including designing and implementing data migrations.
* Technical options like indexing, caching, query optimization, partitioning, sharding 
* Techniques to achieve or maintain consistency across replicated or distributed data.

Software architects know the challenges of:

* shared, distributed or replicated data, like write conflicts, integrity violations, inconsistencies.
* versioning of data structures and data.


[[LG-4-06]]
==== LG 4-06: Improve runtime behavior of systems

Know and be able to apply technology-specific patterns and practices to improve runtime properties (specific choices are at the training provider’s discretion).

[[LG-4-07]]
==== LG 4-07: Improve system operability using suitable practices

(Possibly technology specific) patterns and practices to improve system operations (specific choices are at the training provider’s discretion).

[[LG-4-08]]
==== LG 4-08:  Improve technical documentation 

Software architects know fundamental options for systematic improvement of technical documentation and can apply these, such as:

* Compliance with established document structures (e.g., templates)
* Targeted reduction of documentation volume through abstraction or focussing on essential topics
* Top-down communication,
* Separation of structural (specific) and conceptual (overarching) contents.
* Modularization of documentation

// end::EN[]


