// tag::DE[]
=== {learning-goals}
[[LZ-1-01]]
==== LZ 1-01: Identifizieren und bewerten von Änderungstreibern in Softwaresystemen

* Funktionale Erweiterung oder Änderung
* Änderung von Qualitätsanforderungen oder -zielen
* Änderungen in technischem oder fachlichen Kontext (z. B. Änderung an externen Schnittstellen)
* Fehlerbehebung
* Organisatorische Änderungen (z. B. Änderungen juristischer Rahmenbedingungen oder Anforderungen, an Organisationsstrukturen in Fachbereichen, Entwicklung oder Betrieb)
* Kosten- oder Aufwandsreduktion, insbesondere bezüglich
** Entwicklungskosten oder -aufwände
** Betriebskosten oder -aufwände
** Kosten der Fehlerbehebung und Kosten von Folgeschäden
** Kosten beteiligter Prozesse
** Opportunitätskosten
* Intrinsische Motivation beteiligter Personen, insbesondere Softwareentwickler:innen und -architekt:innen
* Aktualisierung verwendeter Technologien, etwa Betriebssysteme, Middleware, Bibliotheken, Frameworks, Hardware oder ähnliche.

[[LZ-1-02]]
==== LZ 1-02: Erkennen und klassifizieren technischer und organisatorischer Defizite

Softwarearchitekt:innen sollten verschiedene Arten von technischen und organisatorischen Defiziten (_Schulden_) erkennen (siehe <<LZ-2-02>>) und benennen können, beispielsweise:

* Konzeptionelle Schwächen, beispielsweise Verletzung konzeptioneller Integrität, übermässige Redundanz
* Strukturelle Probleme in Daten oder Datenstrukturen
* Strukturelle Probleme im Quellcode, etwa:
** fehlende oder unzureichende Modularisierung,
** enge Kopplung,
** hohe Komplexität,
** geringe Kohäsion,
** handwerkliche Schwächen in der Programmierung, etwa nicht-idiomatische Verwendung von Programmiersprachen oder –werkzeugen,
* Probleme mit Anwendungsdaten, Datenstrukturen oder Datenspeicherung
* Laufzeitprobleme in Systemen, etwa Instabilität, mangelnde Robustheit oder Zuverlässigkeit, mangelnde Performance oder zu hoher Ressourcenbedarf, mangelnde Skalierbarkeit
* Probleme bei Erreichung von Qualitätsanforderungen, etwa mangelnde Änderbarkeit, Verständlichkeit, Flexibilität, Sicherheit, Testbarkeit, Portabilität oder andere für das jeweilige System oder Umfeld relevante Qualitätseigenschaften (siehe etwa <<iso25010>> oder <<Q42>>),
* Technische Schwächen: Verwendung nicht angemessener Technologien, falsche Verwendung von Technologien,
* Probleme oder hohe Risiken im Bereich Sicherheit (Datensicherheit, Vertraulichkeit, Zugangsschutz oä),
* Probleme in Arbeitsprozessen oder -abläufen rund um Systeme, beispielsweise:
** Probleme mit Tests, Testvorgehen, Testdaten, Testausführung, Testumgebungen,
** Probleme mit Freigabe/Release, Deployment, Betrieb, Monitoring/Alerting,
** Probleme aufgrund von fehlendem Wissen, fehlender oder mangelhafter Dokumentation,
** Probleme in Kommunikation mit/zwischen Stakeholdern

See <<kruchtenTechDebt>>, <<starke-debt>>, <<ernst-techDebt>>.

[[LZ-1-03]]
==== LZ 1-03: Differenzieren zwischen Problemen, Ursachen und Lösungsansätzen

Softwarearchitekt:innen können den Begriff der "technischen und organisatorischen Schulden" (siehe <<LZ-1-02>>) erklären, und insbesondere gegenüber dem Schuldenbegriff in Wirtschaft und Finanzwesen differenzieren.
Hierzu gehören insbesondere:

* Verstehen, dass "Schulden” im Zusammenhang mit IT-Systemen eine Metapher und kein wirkliches Finanzkonstrukt sind. 
* Schulden in Wirtschaft und Finanzen besitzen klar definierte (z.T. gesetzlich geregelte) Mechanismen:
** einen vorab definierten quantifizierten Betrag (d.h. quantifizierte _Höhe der Schulden_),
** formalisierte Rollen und Verantwortlichkeiten (Gläubiger, Schuldner),
** vereinbarte Zins- und Tilgungspläne (d.h. Rückführung der Schulden vorab definiert)
** formale rechtliche und buchhalterische Behandlung

Softwarearchitekt:innen können weitere Grundbegriffe von Softwareevolution, -änderung und -verbesserung differenzieren und erklären, beispielsweise:

* Problem (Issue)
* Lösungsansatz (Möglichkeit zur Verbesserung)
* Kosten (von Problemen, Lösungsansätzen, Maßnahmen)
* Ursachen (Root cause) versus Symptom
* Risiko

[[LZ-1-04]]
==== LZ 1-04: Differenzieren möglicher Verbesserungsstrategien für IT-Systeme


* Ad-hoc- oder einmalige Verbesserungen:
** Kleine, situationsbezogene Korrekturen ohne systematischen Plan, in der Regel zur Beseitigung eines akuten Problems oder eines dringenden Mangels.
** In der Regel als Reaktion auf ein unmittelbares Problem.

* Refactoring (lokale strukturelle Verbesserung)
** Gezielte Umstrukturierung von Code oder Architektur ohne Änderung des Verhaltens. 
** Wissenschaftlich definiert (von <<opdyke>>) und primär durch <<fowler>> und <<refactoring>> der Allgemeinheit zugänglich gemacht. 
** Umfasst strukturierte, definierte, reproduzierbare und umkehrbare Operationen, mit dem Ziel, die Übersichtlichkeit zu verbessern, die Komplexität zu verringern oder Änderungen zu isolieren.
** Wird oft proaktiv durchgeführt.

* Inkrementelle oder kontinuierliche Verbesserung, _evolutionäre Veränderung_
** Schrittweise, fortlaufende Verbesserungsmaßnahmen, eingebettet in reguläre Entwicklung.
** Zielt oft auf interne Qualität und Wartbarkeit ab.
** Umfang oft auf lokaler oder Subsystemebene.
** Kleine, kumulative Schritte.

* Konzeptionelle oder architektonische Überarbeitung (Re-Architecting / Reengineering), _transformative Veränderung_
** Größere Neugestaltung grundlegender Strukturen, Konzepten oder Mustern, um die konzeptionelle Integrität wiederherzustellen oder an neue Anforderungen anzupassen
** Umfang oft auf Systemebene oder übergreifende Neugestaltung, die Kernkonzepte oder den Technologie-Stack betrifft
** Wesentliche Änderung der Architekturprinzipien, Komponentenstrukturen oder Laufzeittopologie

* Ersatz oder Neuentwicklung (Neuschreiben, manchmal auch _Big Bang_ genannt)
** Entwicklung eines neuen Systems oder Subsystems, wenn das bestehende System aufgrund massiver Probleme oder geänderte Anforderungen inkrementelle Verbesserungen unwirtschaftlich macht.

// end::DE[]


// tag::EN[]
=== {learning-goals}

[[LG-1-01]]
==== LG 1-01: Identify and evaluate drivers for software changes

* Extending and changing features
* Change in quality requirements and goals
* Changes in technical or business context (e.g., change in external interfaces)
* Bug fixing
* Changes in organization (e.g., changes of legal conditions or requirements, organizational structure of business units, development or operations)
* Reduce of costs or efforts, especially with respect to:
** Costs or efforts of development
** Costs or efforts of operations
** Costs of bug fixing and consequential damage
** Costs of involved processes
** Opportunity costs
* Intrinsic motivation of stakeholders, especially software developers and architects.
* Update of applied technology such as operating systems, middleware, libraries, frameworks, hardware or similar.

[[LG-1-02]]
==== LG 1-02: Recognize and classify technical and organizational deficits

Software architects should be able to recognize and identify various types of technical and organizational deficits (_debts_) (see <<LG-2-02>>), for example:

* Conceptual weaknesses, such as violation of conceptual integrity, excessive redundancy
* Structural problems in data or data structures
* Structural problems in the source code, such as:
** missing or insufficient modularization,
** tight coupling,
** high complexity,
** low cohesion,
** technical weaknesses in programming, such as non-idiomatic use of programming languages or tools
* Problems with application data, data structures, or data storage
* Runtime problems in systems, such as instability, lack of robustness or reliability, poor performance or excessive resource requirements, lack of scalability
* Problems in meeting quality requirements, such as lack of changeability, comprehensibility, flexibility, security, testability, portability, or other quality characteristics relevant to the respective system or environment (see, for example, <<iso25010>> or <<Q42>>)
* Technical weaknesses: use of inappropriate technologies, incorrect use of technologies
* Problems or high risks in the area of security (data security, confidentiality, access protection, etc.)
* Problems in work processes or procedures related to systems, for example:
** Problems with tests, test procedures, test data, test execution, test environments
** Problems with approval/release, deployment, operation, monitoring/alerting
** Problems due to lack of knowledge, missing or inadequate documentation
** Problems in communication with/between stakeholders

See <<kruchtenTechDebt>>, <<starke-debt>>, <<ernst-techDebt>>.

[[LG-1-03]]
==== LG 1-03: Differentiate between problems, root causes, and solutions

Software architects can explain the concept of “technical and organizational debt” (see <<LG-1-02>>) and, in particular, differentiate it from the concept of debt in economics and finance.
This includes, in particular:

* Understanding that “debt” in the context of IT systems is a metaphor and not a real financial construct. 
* Debt in economics and finance has clearly defined (in some cases legally regulated) mechanisms:
** a predefined quantified amount (i.e., quantified _amount of debt_),
** formalized roles and responsibilities (creditor, debtor),
** agreed interest and repayment plans (i.e., repayment of debt defined in advance)
** formal legal and accounting treatment


Software architects can differentiate and explain additional core terms of software evolution and change, for example:

* Problem (issue)
* Solution approach (opportunity for improvement)
* Costs (of problems, solution approaches, measures)
* Root cause versus symptom
* Risk

[[LG-1-04]]
==== LG 1-04: Differentiate types of improvement strategies for IT systems

* Ad-hoc or One-time Improvements:
** Small, situational fixes applied without a systematic plan, typically to remove an acute pain point or urgent defect
** Usually done as reaction to immediate problem

* Refactoring (local structural improvement)
** Focused restructuring of code or architecture without changing behavior. 
** Scientifically defined (by <<opdyke>>) and defined for a broad audience, primarily by <<fowler>> and <<refactoring>>, following structured, defined, reproducible and invertable sets of operations,
** aiming to improve clarity, reduce complexity, or isolate changes,
** often done proactively.

* Incremental or Continuous Improvement, _evolutionary change_
** Stepwise, ongoing improvement activities embedded in regular development
** often targeting internal quality and maintainability
** Scope often on local or subsystem level
** small, cumulative steps

* Conceptual or Architectural Rework (Re-Architecting / Reengineering), _transformational change_
** Larger-scale redesign of architectural structures, concepts, or patterns to restore conceptual integrity or align with new requirements
** Scope often on system-level or cross-cutting redesign affecting core concepts, or technology stack
** substantial change to architectural principles, component structures, or runtime topology

* Replacement or Redevelopment (Rewrite, sometimes called _big bang_)
** Creating a new system or subsystem when accumulated debt, conceptual decay, or changed requirements make incremental improvement uneconomical.

// end::EN[]


